import asyncio
import ujson

from aiogram import Bot, F, Dispatcher, types
from aiogram.filters import CommandStart
from aiogram.types import CallbackQuery, InputMediaPhoto

import keyboards

with open('data.json', 'r', encoding='utf-8') as config_file:
    data = ujson.load(config_file)
    config_file.close()
teachers = data['teachers'].keys()
subjects = data['subjects']
themes = []
for sub in subjects.keys():
    for theme in subjects[sub]:
        themes.append(f'{sub}\\{theme}')

bot = Bot(token=data['token'])
dp = Dispatcher()

teachers_texting = {
}
teachers_img = {
}


# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def main():
    await bot.delete_webhook(drop_pending_updates=True)
    print('Done!')
    await dp.start_polling(bot)


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ /start
@dp.message(CommandStart())
async def start(msg: types.Message):
    await msg.answer_sticker('CAACAgIAAxkBAANzZhJ4OrrcU5f5LOYlC7Huqac6Pg4AAtgPAAJI8mBLFfvE2nh0a5g0BA')

    if str(msg.from_user.id) in teachers:
        await msg.answer(data['start_text'], reply_markup=keyboards.teacher_main_keyboard)
    else:
        await msg.answer(data['start_text'], reply_markup=keyboards.main_keyboard)


# –ü—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É "–ù–∞–∑–∞–¥"; –í—ã–±–æ—Ä –¥–µ–π—Å—Ç–≤–∏—è
@dp.message(F.text == '–ù–∞–∑–∞–¥ üéí')
async def back(msg: types.Message):
    await msg.answer(data['start_text'], reply_markup=keyboards.main_keyboard)


# –ü—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É "–ü—Ä–µ–¥–º–µ—Ç—ã"; –í—ã–±–æ—Ä –ø—Ä–µ–¥–º–µ—Ç–∞
@dp.message(F.text == '–ü—Ä–µ–¥–º–µ—Ç—ã üìö')
async def subjects(msg: types.Message):
    await msg.answer('–í—ã–±–µ—Ä–µ—Çe —à–∫–æ–ª—å–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç üè´', reply_markup=keyboards.subjects_keyboard)


# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª –ø—Ä–µ–¥–º–µ—Ç; –í—ã–±–æ—Ä —Ç–µ–º—ã
@dp.message(F.text.in_(data['subjects'].keys()))
async def select_subject(msg: types.Message):
    await msg.answer('–í—ã–±–µ—Ä–µ—Çe —Ç–µ–º—É üìñ', reply_markup=keyboards.generate_themes_keyboard(msg.text))


# –ù–∞–ø–∏—Å–∞–Ω–∏–µ –ª–µ–∫—Ü–∏–∏
@dp.message(F.text == '–î–æ–±–∞–≤–∏—Ç—å –ª–µ–∫—Ü–∏—é')
async def subjects(msg: types.Message):
    if str(msg.from_user.id) not in teachers:
        return

    await msg.answer('–û—Ç–ø—Ä–∞–≤—å—Ç–µ –ª–µ–∫—Ü–∏—é (–º–æ–∂–Ω–æ –ø–æ —á–∞—Å—Ç—è–º)', reply_markup=keyboards.editing)
    teachers_texting[msg.from_user.id] = ''
    teachers_img[msg.from_user.id] = []


# –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π
@dp.message(F.text == '–ó–∞–∫–æ–Ω—á–∏—Ç—å ‚úî')
async def subjects(msg: types.Message):
    if str(msg.from_user.id) not in teachers:
        return

    await msg.answer('–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏', reply_markup=keyboards.send_photo)


@dp.message(F.photo)
async def on_photo(msg: types.Message):
    if msg.from_user.id not in teachers or teachers_img[msg.from_user.id] is None:
        return

    teachers_img[msg.from_user.id].append(msg.photo)
    await msg.answer('–ï—Å–ª–∏ —ç—Ç–æ –≤—Å–µ —Ñ–æ—Ç–æ —Ç–æ –Ω–∞–∂–º–∏—Ç–µ –∑–∞–≤–µ—Ä—à–∏—Ç—å', reply_markup=keyboards.send_photo)


@dp.message(F.text)
async def all_msg(msg: types.Message):
    if msg.from_user.id not in teachers or teachers_texting[msg.from_user.id] is None:
        return

    await msg.answer('–ï—Å–ª–∏ —ç—Ç–æ –≤—Å—ë, —Ç–æ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∑–∞–∫–æ–Ω—á–∏—Ç—å', reply_markup=keyboards.editing)


# –ü—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"
@dp.callback_query(F.data == 'to_main')
async def to_main(callback: CallbackQuery):
    await callback.answer()
    await callback.message.answer(data['start_text'], reply_markup=keyboards.main_keyboard)


# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ª–µ–∫—Ü–∏–∏         (–Ø –Ω–µ —É—Å–ø–µ–ª —Å–¥–µ–ª–∞—Ç—å!!!)         ;((((
@dp.callback_query(F.data == 'done')
async def to_main(callback: CallbackQuery):
    global data, teachers, subjects, themes
    await callback.answer()
    await callback.message.answer('–û—Ç–ª–∏—á–Ω–æ!', reply_markup=keyboards.teacher_main_keyboard)

    info = {
        "subjects": {
            data['teachers'].get(str(callback.from_user.id)): {
            "theme1": {
                "text": teachers_texting[callback.from_user.id],
                "photos": teachers_img[callback.from_user.id]
                }
            }
        }
    }

    # data['subjects'][data['teachers'][str(callback.from_user.id)]]["theme1"] = {
    #     "text": teachers_texting[callback.from_user.id],
    #     "photos": teachers_img[callback.from_user.id]
    # }
    info = ujson.dumps(data)
    info = ujson.loads(str(info))

    with open('_data.json', 'w') as file:
        ujson.dump(info, file, indent=4)
        file.close()

    teachers_texting.pop(F.data.from_user.id)
    teachers_img.pop(F.data.from_user.id)
    with open('data.json', 'r', encoding='utf-8') as config_file:
        data = ujson.load(config_file)
        config_file.close()
    teachers = data['teachers'].keys()
    subjects = data['subjects']
    themes = []
    for sub in subjects.keys():
        for theme in subjects[sub]:
            themes.append(f'{sub}\\{theme}')


# –ü—Ä–∏ –≤—ã–±–æ—Ä–µ —Ç–µ–º—ã; –û—Ç–ø—Ä–∞–≤–∫–∞ –ª–µ–∫—Ü–∏–∏
@dp.callback_query(F.data.in_(themes))
async def callbacks_on_select_theme(callback: CallbackQuery):
    await callback.answer()
    callback_data = callback.data.split('\\')
    subject = callback_data[0]
    theme = callback_data[1]

    if len(data['subjects'][subject][theme]['photos']) != 0:
        await callback.message.answer_media_group(
            [InputMediaPhoto(media=photo) for photo in data['subjects'][subject][theme]['photos']])
    await callback.message.answer(text=f'{theme}\n\n{data['subjects'][subject][theme]['text']}',
                                  reply_markup=keyboards.generate_themes_keyboard(subject))


if __name__ == '__main__':
    asyncio.run(main())
